#!/usr/bin/env python3
"""
Универсальный конвертер DK1 -> DK2:
- Преобразование Map.kld (ландшафт и сердца)
- Генерация Players.kld с точными блоками игроков
- Поиск кластеров сердечников при помощи deque
"""
import struct
from pathlib import Path
import numpy as np
from collections import deque  # поиск кластеров сердечников


def convert_slb_to_map_kld(slb_path: Path, own_path: Path, map_output: Path):
    """
    Конвертация карты .SLB/.OWN DK1 в Map.kld DK2.
    """
    slb_raw = slb_path.read_bytes()
    own_raw = own_path.read_bytes()
    total = len(slb_raw) // 2
    side = int(total**0.5)
    H = W = side

    slabs = np.frombuffer(slb_raw, dtype="<H").reshape((H, W))
    own = np.frombuffer(own_raw, dtype=np.uint8).reshape((256, 256))

    conv_base = {
        0:1, 1:6, 2:2, 3:2,
        4:9,5:9,6:9,7:9,8:9,9:9,
        10:3,11:8,12:5,13:4,14:12,15:9,
        16:10,17:9,18:15,19:9,20:20,21:9,
        22:21,23:9,24:16,25:9,26:14,27:9,
        28:19,29:9,30:24,31:9,32:22,33:9,
        34:23,35:9,36:13,37:9,38:11,39:9,
        40:25,41:9,51:17,52:7,53:18
    }
    owner_map = {0:3,1:4,2:5,3:6,4:1,5:2}

    base   = np.zeros((H, W), dtype=np.uint8)
    owner  = np.full((H, W), 3, dtype=np.uint8)
    drape  = np.zeros((H, W), dtype=np.uint8)

    for y in range(H):
        for x in range(W):
            sid = int(slabs[y, x])
            base[y, x] = conv_base.get(sid, 1)
            oy, ox = y*3+1, x*3+1
            if oy < 256 and ox < 256:
                owner[y, x] = owner_map.get(int(own[oy, ox]), 3)

    visited = np.zeros((H, W), dtype=bool)
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]
    for y in range(H):
        for x in range(W):
            if slabs[y, x] == 26 and not visited[y, x]:
                # поиск кластеров сердечников
                q = deque([(y, x)])
                visited[y, x] = True
                cluster = [(y, x)]
                while q:
                    cy, cx = q.popleft()
                    for dy, dx in dirs:
                        ny, nx = cy + dy, cx + dx
                        if 0 <= ny < H and 0 <= nx < W and not visited[ny, nx] and slabs[ny, nx] == 26:
                            visited[ny, nx] = True
                            q.append((ny, nx))
                            cluster.append((ny, nx))
                cy = round(sum(p[0] for p in cluster) / len(cluster))
                cx = round(sum(p[1] for p in cluster) / len(cluster))
                heart_owner = owner_map.get(int(own[cy*3+1, cx*3+1]), 3)
                for yy in range(cy-2, cy+3):
                    for xx in range(cx-2, cx+3):
                        if 0 <= yy < H and 0 <= xx < W:
                            base[yy, xx] = 14
                            owner[yy, xx] = heart_owner

    section_size = W * H * 4 + 36
    header = bytearray()
    for v in [100, 4, section_size, 101, 8, W, H, 102, section_size]:
        header += struct.pack("<I", v)
    body = bytearray()
    for y in range(H):
        for x in range(W):
            body += bytes([base[y, x], owner[y, x], 1, drape[y, x]])

    map_output.write_bytes(header + body)


# === Players.kld ===
system_block = bytearray([
    180,0,0,0,4,0,0,0, 0,0,0,0,181,0,0,0,
    28,0,0,0,4,0,0,0, 1,0,0,0,233,7,23,4,
    0,0,23,0, 0,0,233,7,23,4, 0,2,23,0,0,0,
    182,0,0,0,52,3,0,0
])
player_blocks = {
    4: bytearray([  # белый
        184,11,0,0,0,0,0,0,0,1,50,10,0,0,0,0,
        0,0,0,0,1,0,0,0,0,0,0,0,0,25,2,0,
        1,0,25,1,2,3,4,6,7,8,9,10,11,12,13,14,
        15,16,0,4,240,0,1,0,0,0,1,0,0,0,2,2,
        0,99,1,0,0,0,1,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,8,20,2,3,2,50,
        100,0,208,7,1,5,1,0,0,0,125,2,5,10,100,0,
        1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,
        1,20,0,15,1,0,0,0,2,2,2,1,200,42,40,35,
        90,0,100,0,0,0,10,0,15,0,1,0,1,0,23,0,
        23,0,0,0,90,0,0,0,1,0,0,0,0,71,111,111,
        100,32,80,108,97,121,101,114,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0
    ]),
    5: bytearray([  # нейтральный
        184,11,0,0,0,0,0,0,0,1,50,10,0,0,0,0,
        0,0,0,0,1,0,0,0,0,0,0,0,0,25,2,0,
        1,0,25,1,2,3,4,6,7,8,9,10,11,12,13,14,
        15,16,0,4,240,0,1,0,0,0,1,0,0,0,2,2,
        0,99,1,0,0,0,1,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,8,20,2,3,2,50,
        100,0,208,7,1,5,1,0,0,0,125,2,5,10,100,0,
        1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,
        1,20,0,15,1,0,0,0,2,2,2,1,200,42,40,35,
        90,0,100,0,0,0,10,0,15,0,1,0,1,0,23,0,
        23,0,0,0,90,0,0,0,2,0,0,0,0,78,101,117,
        116,114,97,108,32,80,108,97,121,101,114,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0
    ]),
    0: bytearray([  # красный
        184,11,0,0,0,0,0,0,0,1,50,10,0,0,0,0,
        0,0,0,0,1,0,0,0,0,0,0,0,0,25,2,0,
        1,0,25,1,2,3,4,6,7,8,9,10,11,12,13,14,
        15,16,0,4,240,0,1,0,0,0,1,0,0,0,2,2,
        0,99,1,0,0,0,1,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,8,20,2,3,2,50,
        100,0,208,7,1,5,1,0,0,0,125,2,5,10,100,0,
        1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,
        1,20,0,15,1,0,0,0,2,2,2,1,200,42,40,35,
        90,0,100,0,0,0,10,0,15,0,1,0,1,0,23,0,
        23,0,0,0,90,0,0,0,3,0,0,3,0,75,101,101,
        112,101,114,32,49,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0
    ]),
    1: bytearray([  # синий
        184,11,0,0,0,0,0,0,0,1,50,10,0,0,0,0,
        0,0,0,0,1,0,0,0,0,0,0,0,0,25,2,0,
        1,0,25,1,2,3,4,6,7,8,9,10,11,12,13,14,
        15,16,0,4,240,0,1,0,0,0,1,0,0,0,2,2,
        0,99,1,0,0,0,1,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,8,20,2,3,2,50,
        100,0,208,7,1,5,1,0,0,0,125,2,5,10,100,0,
        1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,
        1,20,0,15,1,0,0,0,2,2,2,1,200,42,40,35,
        90,0,100,0,0,0,10,0,15,0,1,0,1,0,83,0,
        83,0,0,0,90,0,0,0,4,0,0,22,0,75,101,101,
        112,101,114,32,50,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0
    ]),
    2: bytearray([  # зеленый
        184,11,0,0,0,0,0,0,0,1,50,10,0,0,0,0,
        0,0,0,0,1,0,0,0,0,0,0,0,0,25,2,0,
        1,0,25,1,2,3,4,6,7,8,9,10,11,12,13,14,
        15,16,0,4,240,0,1,0,0,0,1,0,0,0,2,2,
        0,99,1,0,0,0,1,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,8,20,2,3,2,50,
        100,0,208,7,1,5,1,0,0,0,125,2,5,10,100,0,
        1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,
        1,20,0,15,1,0,0,0,2,2,2,1,200,42,40,35,
        90,0,100,0,0,0,10,0,15,0,1,0,1,0,23,0,
        23,0,0,0,90,0,0,0,5,0,0,3,0,75,101,101,
        112,101,114,32,51,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0
    ]),
    3: bytearray([  # желтый
        184,11,0,0,0,0,0,0,0,1,50,10,0,0,0,0,
        0,0,0,0,1,0,0,0,0,0,0,0,0,25,2,0,
        1,0,25,1,2,3,4,6,7,8,9,10,11,12,13,14,
        15,16,0,4,240,0,1,0,0,0,1,0,0,0,2,2,
        0,99,1,0,0,0,1,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,8,20,2,3,2,50,
        100,0,208,7,1,5,1,0,0,0,125,2,5,10,100,0,
        1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,
        1,20,0,15,1,0,0,0,2,2,2,1,200,42,40,35,
        90,0,100,0,0,0,10,0,15,0,1,0,1,0,23,0,
        23,0,0,0,90,0,0,0,6,0,0,3,0,75,101,101,
        112,101,114,32,52,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0
    ]),
}

def find_owners(own_path: Path):
    raw = own_path.read_bytes()
    arr = np.frombuffer(raw, dtype=np.uint8)
    owners = [4, 5]  # белый и нейтральный всегда в начале
    for r in (0,1,2,3):
        if r in arr:
            owners.append(r)
    return owners

def patch_system_block(n: int):
    # теперь меняем второй счетчик во второй строке (байты 20-23)
    system_block[20:24] = n.to_bytes(4, 'little')
    mapping = {3:(103,2),4:(52,3),5:(1,4),6:(206,4)}
    b0, b1 = mapping[n]
    system_block[-4:] = bytes((b0, b1, 0, 0))


def generate_players_kld(slb_path: Path, own_path: Path, ply_out: Path):
    owners = find_owners(own_path)
    patch_system_block(len(owners))
    out = bytearray(system_block)
    for r in owners:
        out += player_blocks[r]
    ply_out.write_bytes(out)
    return ply_out


if __name__ == "__main__":
    import sys
    slb     = Path(sys.argv[1])
    own     = Path(sys.argv[2])
    base    = slb.with_suffix("")
    map_kld = base.with_suffix(".kld")
    ply_kld = base.with_name(base.name + "_Players.kld")

    print(f"→ Generating {map_kld.name} and {ply_kld.name}")
    convert_slb_to_map_kld(slb, own, map_kld)
    generate_players_kld(slb, own, ply_kld)
    print("Done.")
